<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Oklahoma Investigation Map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

  <style>
    body { margin: 0; }
    #map { height: 100vh; width: 100%; }

    .panel{
      position: absolute;
      left: 10px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.2);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      width: 440px;
      max-width: calc(100vw - 20px);
    }

    #menuWrap{
      top: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #menuHeader{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    #menuTitle{
      font-weight: 700;
      font-size: 14px;
      white-space: nowrap;
    }

    #menuToggle{
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 10px;
      background: #fff;
      font-size: 13px;
      cursor: pointer;
    }

    .menuBody{ display: block; }
    .collapsed .menuBody{ display: none; }

    .row{
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    input, select, button, textarea{
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 14px;
      background: #fff;
      font-family: inherit;
    }
    textarea { width: 100%; min-height: 60px; resize: vertical; }
    #search{ flex: 1; min-width: 200px; }
    label { font-size: 13px; }

    .hint{ font-size: 12px; color: #555; margin-top: 4px; line-height: 1.25; }
    .small{ width: 130px; }
    .grow{ flex: 1; min-width: 160px; }
    .btnRow{ display: flex; gap: 8px; flex-wrap: wrap; }
    .danger{ border-color: #d33 !important; color: #d33 !important; }
    .editMode{ font-size: 12px; color: #0a5; margin-top: 4px; display: none; }

    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
      border: 1px solid rgba(0,0,0,.25);
    }

    .authPill{
      font-size: 12px;
      color: #555;
      border: 1px solid #ddd;
      padding: 4px 8px;
      border-radius: 999px;
      max-width: 220px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .adminBadge{
      font-size: 11px;
      font-weight: 700;
      color: #0a5;
      border: 1px solid #0a5;
      padding: 2px 6px;
      border-radius: 999px;
    }

    @media (max-width: 600px){
      .panel{ width: calc(100vw - 20px); }
      .authPill{ max-width: 140px; }
    }
  </style>
</head>

<body>
  <div id="menuWrap" class="panel collapsed">
    <div id="menuHeader">
      <div id="menuTitle">Investigation Menu</div>

      <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;">
        <span id="adminBadge" class="adminBadge" style="display:none;">ADMIN</span>
        <span id="authState" class="authPill">Not signed in</span>
        <button id="loginBtn" type="button">Sign in</button>
        <button id="logoutBtn" type="button" style="display:none;">Sign out</button>
        <button id="menuToggle" type="button">Open</button>
      </div>
    </div>

    <div class="menuBody">
      <!-- Filters -->
      <div id="controls">
        <div class="row">
          <input id="search" type="text" placeholder="Search location name..." />
          <button id="clearBtn" type="button">Clear</button>
        </div>

        <div class="row">
          <label for="teamFilter">Team:</label>
          <select id="teamFilter">
            <option value="ALL">All</option>
            <option value="Okmulgee Team">Okmulgee Team</option>
            <option value="Tulsa Team">Tulsa Team</option>
            <option value="Unassigned">Unassigned</option>
          </select>

          <label for="statusFilter">Status:</label>
          <select id="statusFilter">
            <option value="ALL">All</option>
            <option value="Active">Active</option>
            <option value="Closed">Closed</option>
            <option value="Unknown">Unknown</option>
          </select>
        </div>

        <div class="row">
          <label for="permissionFilter">Permission:</label>
          <select id="permissionFilter">
            <option value="ALL">All</option>
            <option value="Required">Required</option>
            <option value="Not Required">Not Required</option>
            <option value="Unknown">Unknown</option>
          </select>

          <label for="entityFilter">Entity:</label>
          <select id="entityFilter">
            <option value="ALL">All</option>
            <option value="Ghost">Ghost</option>
            <option value="Demon">Demon</option>
            <option value="Unknown">Unknown</option>
          </select>
        </div>

        <div class="row">
          <label for="typeFilter">Type:</label>
          <select id="typeFilter">
            <option value="ALL">All</option>
            <option value="Cemetery">Cemetery</option>
            <option value="Structure (In Use)">Structure (In Use)</option>
            <option value="Structure (Abandoned)">Structure (Abandoned)</option>
            <option value="Park">Park</option>
            <option value="Lake">Lake</option>
            <option value="Road/Bridge">Road/Bridge</option>
            <option value="Other">Other</option>
            <option value="Unknown">Unknown</option>
          </select>
        </div>
      </div>

      <!-- Section Overlays -->
      <div style="margin-top:10px;">
        <div class="row" style="margin-bottom:2px;">
          <strong>Section Overlays</strong>
        </div>

        <div class="row">
          <label for="sectionMapFilter">View:</label>
          <select id="sectionMapFilter" class="grow"></select>
        </div>

        <div id="sectionAdminTools" style="display:none;">
          <div class="row">
            <input id="sectionMapName" class="grow" type="text" placeholder="Map name for NEW sections (ex: Crown Hill Cemetery)" />
            <input id="sectionNextNumber" class="small" type="number" min="1" step="1" placeholder="Next #" />
          </div>

          <div class="row">
            <label for="sectionDefaultStatus">Default:</label>
            <select id="sectionDefaultStatus" class="small">
              <option value="uninvestigated">White (Uninvestigated)</option>
              <option value="possible">Yellow (Possible)</option>
              <option value="confirmed">Green (Confirmed)</option>
            </select>
          </div>

          <div class="hint">
            Admin only: draw rectangles/polygons using the toolbar on the map (top-right). Click a section/hex to cycle status.
          </div>
        </div>

        <div class="hint">
          Status colors: White = uninvestigated, Yellow = possible activity, Green = confirmed activity.
        </div>
      </div>

      <!-- County Highlights (no header text as requested) -->
      <div style="margin-top:10px;">
        <div class="row" style="margin-bottom:4px;">
          <span class="dot" style="background:#e31a1c;"></span>
          <strong style="font-size:13px;">Red</strong>
        </div>
        <div class="row" id="countyHighlightControlsRed"></div>

        <div class="row" style="margin:8px 0 4px;">
          <span class="dot" style="background:#33a02c;"></span>
          <strong style="font-size:13px;">Green</strong>
        </div>
        <div class="row" id="countyHighlightControlsGreen"></div>
      </div>

      <!-- New Location Form -->
      <div id="newLocationPanel" style="margin-top:10px;">
        <div class="row">
          <strong>New Location</strong>
          <span class="hint">Tip: click “Pick from map”, then click the map to fill lat/lng.</span>
        </div>

        <div id="mustLoginNote" class="hint" style="display:none;">
          Sign in with your @prcofok.org Google account to add locations.
        </div>

        <div id="editModeBanner" class="editMode">Editing an existing pin. Submit will UPDATE it.</div>

        <form id="newLocationForm">
          <div class="row">
            <input id="nl_name" class="grow" type="text" placeholder="Location name (required)" required />
            <select id="nl_team" class="small">
              <option value="Unassigned">Unassigned</option>
              <option value="Okmulgee Team">Okmulgee Team</option>
              <option value="Tulsa Team">Tulsa Team</option>
            </select>
          </div>

          <div class="row">
            <select id="nl_type" class="small">
              <option value="Unknown">Type: Unknown</option>
              <option value="Cemetery">Type: Cemetery</option>
              <option value="Structure (In Use)">Type: Structure (In Use)</option>
              <option value="Structure (Abandoned)">Type: Structure (Abandoned)</option>
              <option value="Park">Type: Park</option>
              <option value="Lake">Type: Lake</option>
              <option value="Road/Bridge">Type: Road/Bridge</option>
              <option value="Other">Type: Other</option>
            </select>

            <select id="nl_status" class="small">
              <option value="Active">Active</option>
              <option value="Closed">Closed</option>
              <option value="Unknown">Unknown</option>
            </select>

            <select id="nl_permission" class="small">
              <option value="Unknown">Permission: Unknown</option>
              <option value="Required">Permission: Required</option>
              <option value="Not Required">Permission: Not Required</option>
            </select>

            <select id="nl_entity" class="small">
              <option value="Unknown">Entity: Unknown</option>
              <option value="Ghost">Entity: Ghost</option>
              <option value="Demon">Entity: Demon</option>
            </select>
          </div>

          <div class="row">
            <input id="nl_lat" class="small" type="number" step="any" placeholder="Lat" required />
            <input id="nl_lng" class="small" type="number" step="any" placeholder="Lng" required />
            <button id="pickBtn" type="button">Pick from map</button>
          </div>

          <div class="row">
            <textarea id="nl_details" placeholder="Details / notes (optional)"></textarea>
          </div>

          <div class="btnRow">
            <button id="submitBtn" type="submit">Add Location</button>
            <button id="cancelEditBtn" type="button" style="display:none;">Cancel Edit</button>
          </div>

          <div id="pickHint" class="hint" style="display:none;">
            Click the map to set coordinates. Press Esc to cancel.
          </div>
        </form>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
      getFirestore,
      collection,
      addDoc,
      onSnapshot,
      doc,
      updateDoc,
      deleteDoc,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

    import {
      getAuth,
      GoogleAuthProvider,
      signInWithPopup,
      signOut,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

    // ---------------- FIREBASE CONFIG ----------------
    const firebaseConfig = {
      apiKey: "AIzaSyAfAk1hl11uDpC3JB7m0JvwnPf8rVXxJTg",
      authDomain: "oklahoma-investigation-map.firebaseapp.com",
      projectId: "oklahoma-investigation-map",
      storageBucket: "oklahoma-investigation-map.firebasestorage.app",
      messagingSenderId: "809288424180",
      appId: "1:809288424180:web:6b6989762ea7db99151ca1"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Collections
    const LOCATIONS = "locations";
    const SECTIONS  = "section_overlays";

    function setStatus(msg){
      console.log("[Firestore]", msg);
    }

    // ---------------- AUTH ----------------
    const auth = getAuth(app);
    const provider = new GoogleAuthProvider();

    const ALLOWED_DOMAIN = "@prcofok.org";
    const ADMIN_EMAILS = new Set(["fclegg@prcofok.org"]);

    let currentUser = null;
    let isMember = false; // signed-in + correct domain
    let isAdmin = false;  // fclegg@prcofok.org

    // ----- DOM -----
    const menuWrap = document.getElementById("menuWrap");
    const menuToggle = document.getElementById("menuToggle");

    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const authStateEl = document.getElementById("authState");
    const adminBadgeEl = document.getElementById("adminBadge");

    const searchEl = document.getElementById("search");
    const clearBtn = document.getElementById("clearBtn");
    const teamFilterEl = document.getElementById("teamFilter");
    const statusFilterEl = document.getElementById("statusFilter");
    const permissionFilterEl = document.getElementById("permissionFilter");
    const entityFilterEl = document.getElementById("entityFilter");
    const typeFilterEl = document.getElementById("typeFilter");

    const countyControlsRed = document.getElementById("countyHighlightControlsRed");
    const countyControlsGreen = document.getElementById("countyHighlightControlsGreen");

    const newLocationPanel = document.getElementById("newLocationPanel");
    const mustLoginNote = document.getElementById("mustLoginNote");

    const editModeBanner = document.getElementById("editModeBanner");
    const cancelEditBtn = document.getElementById("cancelEditBtn");
    const submitBtn = document.getElementById("submitBtn");

    const form = document.getElementById("newLocationForm");
    const nl_name = document.getElementById("nl_name");
    const nl_team = document.getElementById("nl_team");
    const nl_type = document.getElementById("nl_type");
    const nl_status = document.getElementById("nl_status");
    const nl_permission = document.getElementById("nl_permission");
    const nl_entity = document.getElementById("nl_entity");
    const nl_lat = document.getElementById("nl_lat");
    const nl_lng = document.getElementById("nl_lng");
    const nl_details = document.getElementById("nl_details");
    const pickBtn = document.getElementById("pickBtn");
    const pickHint = document.getElementById("pickHint");

    // Section overlay DOM
    const sectionMapFilter = document.getElementById("sectionMapFilter");
    const sectionAdminTools = document.getElementById("sectionAdminTools");
    const sectionMapName = document.getElementById("sectionMapName");
    const sectionNextNumber = document.getElementById("sectionNextNumber");
    const sectionDefaultStatus = document.getElementById("sectionDefaultStatus");

    function setMenuCollapsed(collapsed){
      menuWrap.classList.toggle("collapsed", collapsed);
      menuToggle.textContent = collapsed ? "Open" : "Close";
    }
    menuToggle.addEventListener("click", () => {
      const collapsed = menuWrap.classList.contains("collapsed");
      setMenuCollapsed(!collapsed);
    });
    setMenuCollapsed(window.matchMedia("(max-width: 600px)").matches);

    function refreshAuthUI() {
      if (!currentUser) {
        authStateEl.textContent = "Not signed in";
        loginBtn.style.display = "inline-block";
        logoutBtn.style.display = "none";
        adminBadgeEl.style.display = "none";
        sectionAdminTools.style.display = "none";
        mustLoginNote.style.display = "block";
        return;
      }

      authStateEl.textContent = currentUser.email || "Signed in";
      loginBtn.style.display = "none";
      logoutBtn.style.display = "inline-block";
      adminBadgeEl.style.display = isAdmin ? "inline-block" : "none";
      sectionAdminTools.style.display = isAdmin ? "block" : "none";
      mustLoginNote.style.display = isMember ? "none" : "block";
    }

    loginBtn.addEventListener("click", async () => {
      try {
        const res = await signInWithPopup(auth, provider);
        const email = (res.user?.email || "").toLowerCase();

        // Hard-block anything not your org domain
        if (!email.endsWith(ALLOWED_DOMAIN)) {
          await signOut(auth);
          alert(`Unauthorized account. Use a ${ALLOWED_DOMAIN} Google account.`);
          return;
        }
      } catch (err) {
        console.error(err);
        alert("Sign-in failed: " + (err?.message || err));
      }
    });

    logoutBtn.addEventListener("click", async () => {
      await signOut(auth);
    });

    onAuthStateChanged(auth, (user) => {
      currentUser = user;

      const email = (user?.email || "").toLowerCase();
      isMember = !!user && email.endsWith(ALLOWED_DOMAIN);
      isAdmin = !!user && ADMIN_EMAILS.has(email);

      refreshAuthUI();
      setSectionEditingEnabled(isAdmin);

      // Rebuild marker popups (admin buttons)
      applyFilters();
    });

    // ---------------- MAP ----------------
    const map = L.map('map').setView([35.4676, -97.5164], 7);

    // Base layers (Street + Satellite)
    const streets = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    });

    const satellite = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      {
        maxZoom: 19,
        attribution: "Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community"
      }
    );

    streets.addTo(map);

    L.control.layers(
      { Streets: streets, Satellite: satellite },
      null,
      { position: "topright" }
    ).addTo(map);

    // Locations markers
    const markerLayer = L.layerGroup().addTo(map);
    let markers = [];
    let editingId = null;

    function setEditMode(idOrNull) {
      editingId = idOrNull;
      const on = !!editingId;
      editModeBanner.style.display = on ? "block" : "none";
      cancelEditBtn.style.display = on ? "inline-block" : "none";
      submitBtn.textContent = on ? "Update Location" : "Add Location";
    }

    function makeMarker(loc) {
      const actions = isAdmin ? `
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
          <button type="button" class="editPinBtn" data-id="${loc.id}">Edit</button>
          <button type="button" class="deletePinBtn danger" data-id="${loc.id}">Delete</button>
        </div>` : "";

      return L.marker([loc.lat, loc.lng]).bindPopup(
        `<b>${loc.name}</b><br>
         Type: ${loc.type}<br>
         Team: ${loc.team}<br>
         Status: ${loc.status}<br>
         Permission: ${loc.permission}<br>
         Entity: ${loc.entity}<br><br>
         ${loc.details ? loc.details : ""}
         ${actions}`
      );
    }

    function applyFilters() {
      const teamValue = teamFilterEl.value;
      const statusValue = statusFilterEl.value;
      const permissionValue = permissionFilterEl.value;
      const entityValue = entityFilterEl.value;
      const typeValue = typeFilterEl.value;
      const searchValue = searchEl.value.trim().toLowerCase();

      markerLayer.clearLayers();

      markers.forEach(({ loc, marker }) => {
        const teamOk = (teamValue === "ALL") || (loc.team === teamValue);
        const statusOk = (statusValue === "ALL") || (loc.status === statusValue);
        const permissionOk = (permissionValue === "ALL") || (loc.permission === permissionValue);
        const entityOk = (entityValue === "ALL") || (loc.entity === entityValue);
        const typeOk = (typeValue === "ALL") || (loc.type === typeValue);
        const searchOk = (searchValue === "") || (String(loc.name || "").toLowerCase().includes(searchValue));

        if (teamOk && statusOk && permissionOk && entityOk && typeOk && searchOk) {
          marker.addTo(markerLayer);
        }
      });
    }

    map.on("popupopen", (e) => {
      const popupEl = e.popup.getElement();
      if (!popupEl) return;

      // Only admin gets edit/delete buttons in the popup
      if (!isAdmin) return;

      const editBtn = popupEl.querySelector(".editPinBtn");
      const deleteBtn = popupEl.querySelector(".deletePinBtn");

      if (editBtn) {
        editBtn.addEventListener("click", () => {
          const id = editBtn.dataset.id;
          const loc = markers.find(m => m.loc.id === id)?.loc;
          if (!loc) return alert("Could not find that pin.");

          nl_name.value = loc.name || "";
          nl_team.value = loc.team || "Unassigned";
          nl_type.value = loc.type || "Unknown";
          nl_status.value = loc.status || "Unknown";
          nl_permission.value = loc.permission || "Unknown";
          nl_entity.value = loc.entity || "Unknown";
          nl_lat.value = Number(loc.lat).toFixed(6);
          nl_lng.value = Number(loc.lng).toFixed(6);
          nl_details.value = loc.details || "";

          setEditMode(id);
          alert("Editing mode enabled. Update the form and click Update Location.");
          if (window.matchMedia("(max-width: 600px)").matches) setMenuCollapsed(false);
        });
      }

      if (deleteBtn) {
        deleteBtn.addEventListener("click", async () => {
          const id = deleteBtn.dataset.id;
          if (!confirm("Delete this pin? This cannot be undone.")) return;

          try {
            await deleteDoc(doc(db, LOCATIONS, id));
            if (editingId === id) setEditMode(null);
          } catch (err) {
            console.error(err);
            alert("Delete failed: " + (err?.message || err));
          }
        });
      }
    });

    // Filter events (team changes will ALSO update county highlights)
    teamFilterEl.addEventListener("change", () => {
      applyFilters();
      syncCountyHighlightsToTeamFilter();
    });
    statusFilterEl.addEventListener("change", applyFilters);
    permissionFilterEl.addEventListener("change", applyFilters);
    entityFilterEl.addEventListener("change", applyFilters);
    typeFilterEl.addEventListener("change", applyFilters);
    searchEl.addEventListener("input", applyFilters);

    clearBtn.addEventListener("click", () => {
      teamFilterEl.value = "ALL";
      statusFilterEl.value = "ALL";
      permissionFilterEl.value = "ALL";
      entityFilterEl.value = "ALL";
      typeFilterEl.value = "ALL";
      searchEl.value = "";
      applyFilters();
      syncCountyHighlightsToTeamFilter();
    });

    // Pick coords mode
    let picking = false;
    function setPicking(on) {
      picking = on;
      pickHint.style.display = on ? "block" : "none";
      pickBtn.textContent = on ? "Picking…" : "Pick from map";
      pickBtn.disabled = on;
      map.getContainer().style.cursor = on ? "crosshair" : "";
    }
    pickBtn.addEventListener("click", () => setPicking(true));
    map.on("click", (e) => {
      if (!picking) return;
      nl_lat.value = e.latlng.lat.toFixed(6);
      nl_lng.value = e.latlng.lng.toFixed(6);
      setPicking(false);
      if (window.matchMedia("(max-width: 600px)").matches) setMenuCollapsed(false);
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && picking) setPicking(false);
    });

    cancelEditBtn.addEventListener("click", () => {
      setEditMode(null);
      form.reset();
    });

    // Require sign-in (org account) to ADD pins; only admin can EDIT/DELETE pins
    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      if (!isMember) {
        alert("Sign in with your @prcofok.org Google account to add locations.");
        return;
      }
      if (editingId && !isAdmin) {
        alert("Only admin can edit existing locations.");
        return;
      }

      const name = nl_name.value.trim();
      const team = nl_team.value;

      const type = nl_type.value || "Unknown";
      const status = nl_status.value || "Unknown";
      const permission = nl_permission.value || "Unknown";
      const entity = nl_entity.value || "Unknown";

      const lat = Number(nl_lat.value);
      const lng = Number(nl_lng.value);
      const details = nl_details.value.trim();

      if (!name) return alert("Location name is required.");
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return alert("Valid latitude and longitude are required.");

      const payload = {
        name, team, type, status, permission, entity, lat, lng, details,
        updatedAt: serverTimestamp()
      };

      try {
        if (editingId) {
          await updateDoc(doc(db, LOCATIONS, editingId), payload);
          alert("Location updated!");
          setEditMode(null);
        } else {
          payload.createdAt = serverTimestamp();
          payload.createdBy = currentUser?.email || "";
          await addDoc(collection(db, LOCATIONS), payload);
          alert("Location added!");
        }
        form.reset();
        if (window.matchMedia("(max-width: 600px)").matches) setMenuCollapsed(true);
      } catch (err) {
        console.error(err);
        alert("Save failed: " + (err?.message || err));
      }
    });

    // Real-time listener (locations)
    setStatus("Connecting to Firestore…");
    onSnapshot(
      collection(db, LOCATIONS),
      (snapshot) => {
        setStatus(`Connected.\nCollection: ${LOCATIONS}\nDocs loaded: ${snapshot.size}`);

        markers = [];
        snapshot.forEach((docSnap) => {
          const d = docSnap.data();
          const loc = {
            id: docSnap.id,
            name: d.name || "(Unnamed)",
            type: d.type || "Unknown",
            team: d.team || "Unassigned",
            status: d.status || "Unknown",
            permission: d.permission || "Unknown",
            entity: d.entity || "Unknown",
            lat: Number(d.lat),
            lng: Number(d.lng),
            details: d.details || ""
          };
          if (Number.isFinite(loc.lat) && Number.isFinite(loc.lng)) {
            markers.push({ loc, marker: makeMarker(loc) });
          }
        });

        applyFilters();
      },
      (err) => {
        console.error(err);
        setStatus("Listener error:\n" + (err?.message || err));
      }
    );

    // ---------------- SECTION OVERLAYS ----------------
    const STATUS_COLORS = {
      uninvestigated: "#ffffff", // white
      possible: "#ffeb3b",       // yellow
      confirmed: "#33a02c"       // green
    };

    function makeHexIcon(numberText, status) {
      const fill = STATUS_COLORS[status] || "#ffffff";
      const text = String(numberText ?? "").trim();

      const svg = `
        <svg width="48" height="48" viewBox="0 0 100 100">
          <polygon points="50,5 90,27 90,73 50,95 10,73 10,27"
            fill="${fill}" stroke="#000" stroke-width="6" />
          <text x="50" y="60" text-anchor="middle"
            font-size="36" font-family="Arial" font-weight="700" fill="#000">${text}</text>
        </svg>`;

      return L.divIcon({
        className: "",
        html: svg,
        iconSize: [48, 48],
        iconAnchor: [24, 24]
      });
    }

    function centroidOfLatLngs(latlngs) {
      const ring = Array.isArray(latlngs?.[0]) ? latlngs[0] : latlngs;
      let sumLat = 0, sumLng = 0;
      const n = (ring && ring.length) ? ring.length : 1;
      (ring || []).forEach(p => { sumLat += p.lat; sumLng += p.lng; });
      return L.latLng(sumLat / n, sumLng / n);
    }

    function cycleStatus(s) {
      if (s === "uninvestigated") return "possible";
      if (s === "possible") return "confirmed";
      return "uninvestigated";
    }

    // Thick yellow lines like your screenshots
    function sectionPolyStyle() {
      return { color: "#ffff00", weight: 5, fillOpacity: 0 };
    }

    // Live layers
    const sectionPolys = L.featureGroup().addTo(map);
    const sectionHexes = L.layerGroup().addTo(map);

    // id -> { poly, hex, mapName }
    const sectionById = new Map();

    // Draw control (admin only)
    let drawControl = null;
    function setSectionEditingEnabled(enabled) {
      if (enabled) {
        if (!drawControl) {
          drawControl = new L.Control.Draw({
            position: "topright",
            draw: {
              polygon: true,
              rectangle: true,
              polyline: false,
              circle: false,
              marker: false,
              circlemarker: false
            },
            edit: {
              featureGroup: sectionPolys,
              remove: true
            }
          });
          map.addControl(drawControl);
        }
      } else {
        if (drawControl) {
          map.removeControl(drawControl);
          drawControl = null;
        }
      }
    }

    // Filter dropdown setup
    function ensureSectionFilterOptions(mapNames) {
      const current = sectionMapFilter.value || "ALL";
      const names = Array.from(new Set(mapNames)).filter(Boolean).sort((a,b) => a.localeCompare(b));

      const opts = ["ALL", ...names];

      sectionMapFilter.innerHTML = "";
      opts.forEach(v => {
        const o = document.createElement("option");
        o.value = v;
        o.textContent = (v === "ALL") ? "All section maps" : v;
        sectionMapFilter.appendChild(o);
      });

      // restore selection if possible
      sectionMapFilter.value = opts.includes(current) ? current : "ALL";
    }

    function applySectionFilter() {
      const selected = sectionMapFilter.value || "ALL";
      for (const [id, rec] of sectionById.entries()) {
        const show = (selected === "ALL") || (rec.mapName === selected);
        if (show) {
          if (!sectionPolys.hasLayer(rec.poly)) sectionPolys.addLayer(rec.poly);
          if (!sectionHexes.hasLayer(rec.hex)) sectionHexes.addLayer(rec.hex);
        } else {
          if (sectionPolys.hasLayer(rec.poly)) sectionPolys.removeLayer(rec.poly);
          if (sectionHexes.hasLayer(rec.hex)) sectionHexes.removeLayer(rec.hex);
        }
      }
    }

    sectionMapFilter.addEventListener("change", () => {
      // nice convenience: if admin and they select a specific map, auto-fill name
      const v = sectionMapFilter.value;
      if (isAdmin && v && v !== "ALL") sectionMapName.value = v;
      applySectionFilter();
    });

    // Create section (admin)
    map.on(L.Draw.Event.CREATED, async (e) => {
      if (!isAdmin) return;

      const layer = e.layer;
      layer.setStyle(sectionPolyStyle());
      sectionPolys.addLayer(layer);

      const mapName = (sectionMapName.value || "").trim();
      if (!mapName) {
        alert("Enter a Map name in Section Overlays first (ex: Crown Hill Cemetery).");
        sectionPolys.removeLayer(layer);
        return;
      }

      const numRaw = (sectionNextNumber.value || "").trim();
      const number = numRaw ? String(numRaw) : "1";
      const status = sectionDefaultStatus.value || "uninvestigated";

      const geo = layer.toGeoJSON();

      try {
        const docRef = await addDoc(collection(db, SECTIONS), {
          mapName,
          number,
          status,
          geometry: geo.geometry,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          createdBy: currentUser?.email || ""
        });

        layer.options._sectionId = docRef.id;

        // auto-increment next number if it was numeric
        const n = Number(number);
        if (Number.isFinite(n)) sectionNextNumber.value = String(n + 1);
      } catch (err) {
        console.error(err);
        alert("Save section failed: " + (err?.message || err));
        sectionPolys.removeLayer(layer);
      }
    });

    // Edit geometry (admin)
    map.on(L.Draw.Event.EDITED, async (e) => {
      if (!isAdmin) return;

      const layers = e.layers;
      const updates = [];

      layers.eachLayer((layer) => {
        const id = layer.options._sectionId;
        if (!id) return;
        const geo = layer.toGeoJSON();
        updates.push(updateDoc(doc(db, SECTIONS, id), {
          geometry: geo.geometry,
          updatedAt: serverTimestamp()
        }));
      });

      try {
        await Promise.all(updates);
      } catch (err) {
        console.error(err);
        alert("Update failed: " + (err?.message || err));
      }
    });

    // Delete (admin)
    map.on(L.Draw.Event.DELETED, async (e) => {
      if (!isAdmin) return;

      const layers = e.layers;
      const deletes = [];

      layers.eachLayer((layer) => {
        const id = layer.options._sectionId;
        if (!id) return;
        deletes.push(deleteDoc(doc(db, SECTIONS, id)));
      });

      try {
        await Promise.all(deletes);
      } catch (err) {
        console.error(err);
        alert("Delete failed: " + (err?.message || err));
      }
    });

    function attachSectionInteractions(id, polyLayer, hexMarker) {
      polyLayer.on("click", async () => {
        const rec = sectionById.get(id);
        if (!rec) return;

        // Admin click cycles status immediately
        if (isAdmin) {
          const next = cycleStatus(rec.status);
          try {
            await updateDoc(doc(db, SECTIONS, id), { status: next, updatedAt: serverTimestamp() });
          } catch (err) {
            console.error(err);
            alert("Status update failed: " + (err?.message || err));
          }
          return;
        }

        // Non-admin: show info
        alert(`${rec.mapName}\nSection: ${rec.number}\nStatus: ${rec.status}`);
      });

      // Admin: right-click / context menu to edit label quickly
      polyLayer.on("contextmenu", async () => {
        if (!isAdmin) return;
        const rec = sectionById.get(id);
        if (!rec) return;

        const newMapName = prompt("Map name:", rec.mapName);
        if (!newMapName) return;

        const newNumber = prompt("Section label/number:", rec.number);
        if (!newNumber) return;

        try {
          await updateDoc(doc(db, SECTIONS, id), {
            mapName: newMapName.trim(),
            number: String(newNumber).trim(),
            updatedAt: serverTimestamp()
          });
        } catch (err) {
          console.error(err);
          alert("Label update failed: " + (err?.message || err));
        }
      });

      // Admin click on hex also cycles status
      hexMarker.on("click", async () => {
        if (!isAdmin) return;
        const rec = sectionById.get(id);
        if (!rec) return;

        const next = cycleStatus(rec.status);
        try {
          await updateDoc(doc(db, SECTIONS, id), { status: next, updatedAt: serverTimestamp() });
        } catch (err) {
          console.error(err);
          alert("Status update failed: " + (err?.message || err));
        }
      });
    }

    function rebuildSectionLayerFromDoc(id, d) {
      const mapName = d.mapName || "Unnamed Map";
      const number = d.number || "";
      const status = d.status || "uninvestigated";
      const geom = d.geometry;

      // Remove existing
      const existing = sectionById.get(id);
      if (existing) {
        if (sectionPolys.hasLayer(existing.poly)) sectionPolys.removeLayer(existing.poly);
        if (sectionHexes.hasLayer(existing.hex)) sectionHexes.removeLayer(existing.hex);
        sectionById.delete(id);
      }

      // Create polygon
      const geojson = {
        type: "Feature",
        properties: { id, mapName, number, status },
        geometry: geom
      };

      const gj = L.geoJSON(geojson, {
        style: sectionPolyStyle(),
        onEachFeature: (feature, layer) => {
          layer.options._sectionId = id;
        }
      });

      let polyLayer = null;
      gj.eachLayer(l => polyLayer = l);
      if (!polyLayer) return;

      // Create hex at centroid
      const c = centroidOfLatLngs(polyLayer.getLatLngs());
      const hex = L.marker(c, {
        icon: makeHexIcon(number, status),
        interactive: true,
        zIndexOffset: 1000
      });

      // Store record
      sectionById.set(id, { poly: polyLayer, hex, mapName, number, status });

      // Interactions
      attachSectionInteractions(id, polyLayer, hex);

      // Add to map (respect filter)
      const selected = sectionMapFilter.value || "ALL";
      const show = (selected === "ALL") || (mapName === selected);

      if (show) {
        sectionPolys.addLayer(polyLayer);
        sectionHexes.addLayer(hex);
      }
    }

    // Real-time listener (sections)
    onSnapshot(collection(db, SECTIONS), (snap) => {
      // Keep the dropdown in sync with available map names
      const names = [];
      snap.forEach(docSnap => {
        const d = docSnap.data();
        if (d.mapName) names.push(d.mapName);
      });
      ensureSectionFilterOptions(names);

      snap.docChanges().forEach((ch) => {
        const id = ch.doc.id;

        if (ch.type === "removed") {
          const existing = sectionById.get(id);
          if (existing) {
            if (sectionPolys.hasLayer(existing.poly)) sectionPolys.removeLayer(existing.poly);
            if (sectionHexes.hasLayer(existing.hex)) sectionHexes.removeLayer(existing.hex);
            sectionById.delete(id);
          }
          return;
        }

        const d = ch.doc.data();
        rebuildSectionLayerFromDoc(id, d);
      });

      applySectionFilter();
    });

    // ---------------- COUNTY HIGHLIGHTS ----------------
    const RED_COUNTIES = ["Tulsa","Wagoner","Rogers","Washington","Osage"];
    const GREEN_COUNTIES = ["Creek","Okmulgee","Muskogee","McIntosh","Okfuskee"];

    const RED_BASE = "#e31a1c";
    const GREEN_BASE = "#33a02c";

    const redSet = new Set(RED_COUNTIES);
    const greenSet = new Set(GREEN_COUNTIES);

    const countyLayersByName = {};
    const countyBaseStyleByName = {};
    const highlightState = {};
    const checkboxByCounty = {};

    // Default ON for both groups
    RED_COUNTIES.forEach(c => highlightState[c] = true);
    GREEN_COUNTIES.forEach(c => highlightState[c] = true);

    function hexToRgb(hex){
      const h = (hex || "").replace("#", "").trim();
      if (h.length !== 6) return null;
      const n = parseInt(h, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }
    function rgbToHex({r,g,b}){
      const toHex = (v) => v.toString(16).padStart(2, "0");
      return "#" + toHex(r) + toHex(g) + toHex(b);
    }
    function brighten(hex, amt = 0.45){
      const rgb = hexToRgb(hex);
      if (!rgb) return hex;
      const mix = (c) => Math.round(c + (255 - c) * amt);
      return rgbToHex({ r: mix(rgb.r), g: mix(rgb.g), b: mix(rgb.b) });
    }
    function darken(hex, amt = 0.25){
      const rgb = hexToRgb(hex);
      if (!rgb) return hex;
      const mix = (c) => Math.round(c * (1 - amt));
      return rgbToHex({ r: mix(rgb.r), g: mix(rgb.g), b: mix(rgb.b) });
    }

    function countyGroup(name){
      if (redSet.has(name)) return "red";
      if (greenSet.has(name)) return "green";
      return null;
    }

    function baseCountyStyle() {
      return { color: "#000", weight: 2, fillOpacity: 0.08, fillColor: "#ffffff" };
    }

    function highlightStyleForGroup(group){
      const base = group === "red" ? RED_BASE : GREEN_BASE;
      return {
        color: darken(base, 0.30),
        weight: 4,
        fillOpacity: 0.60,
        fillColor: brighten(base, 0.45)
      };
    }

    function setCountyHighlighted(countyName, on){
      highlightState[countyName] = !!on;

      const layer = countyLayersByName[countyName];
      const base = countyBaseStyleByName[countyName];
      if (!layer || !base) return;

      if (on) {
        const grp = countyGroup(countyName);
        if (grp) {
          layer.setStyle({ ...base, ...highlightStyleForGroup(grp) });
        } else {
          layer.setStyle({ color: "#000", weight: 4, fillOpacity: 0.18, fillColor: "#ffffff" });
        }
        layer.bringToFront();
      } else {
        layer.setStyle(base);
      }
    }

    function addCountyCheckbox(containerEl, countyName, colorHex){
      const id = `hl_${countyName.replace(/\s+/g, "_")}`;

      const wrap = document.createElement("label");
      wrap.style.display = "inline-flex";
      wrap.style.alignItems = "center";
      wrap.style.gap = "6px";
      wrap.style.marginRight = "10px";
      wrap.style.cursor = "pointer";
      wrap.style.userSelect = "none";
      wrap.style.fontSize = "13px";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.id = id;
      cb.checked = !!highlightState[countyName];
      checkboxByCounty[countyName] = cb;

      cb.addEventListener("change", () => setCountyHighlighted(countyName, cb.checked));

      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = colorHex;

      const text = document.createElement("span");
      text.textContent = countyName;

      wrap.appendChild(cb);
      wrap.appendChild(dot);
      wrap.appendChild(text);
      containerEl.appendChild(wrap);
    }

    function buildCountyToggleUI(){
      if (countyControlsRed) countyControlsRed.innerHTML = "";
      if (countyControlsGreen) countyControlsGreen.innerHTML = "";

      RED_COUNTIES.forEach(name => addCountyCheckbox(countyControlsRed, name, RED_BASE));
      GREEN_COUNTIES.forEach(name => addCountyCheckbox(countyControlsGreen, name, GREEN_BASE));
    }

    function setGroupVisibility({ redOn, greenOn }) {
      RED_COUNTIES.forEach(c => {
        highlightState[c] = !!redOn;
        if (checkboxByCounty[c]) checkboxByCounty[c].checked = !!redOn;
        setCountyHighlighted(c, !!redOn);
      });
      GREEN_COUNTIES.forEach(c => {
        highlightState[c] = !!greenOn;
        if (checkboxByCounty[c]) checkboxByCounty[c].checked = !!greenOn;
        setCountyHighlighted(c, !!greenOn);
      });
    }

    function syncCountyHighlightsToTeamFilter(){
      const v = teamFilterEl.value;

      if (v === "Tulsa Team") {
        setGroupVisibility({ redOn: true, greenOn: false });
      } else if (v === "Okmulgee Team") {
        setGroupVisibility({ redOn: false, greenOn: true });
      } else if (v === "ALL") {
        setGroupVisibility({ redOn: true, greenOn: true });
      } else { // Unassigned
        setGroupVisibility({ redOn: false, greenOn: false });
      }
    }

    // Build UI + apply default state
    buildCountyToggleUI();

    // Counties overlay
    fetch("./data/counties_ok.geojson")
      .then(res => {
        if (!res.ok) throw new Error("Counties file not found: ./data/counties_ok.geojson");
        return res.json();
      })
      .then(counties => {
        L.geoJSON(counties, {
          style: () => baseCountyStyle(),
          onEachFeature: (feature, layer) => {
            const name = feature?.properties?.NAME;
            if (!name) return;

            countyLayersByName[name] = layer;
            countyBaseStyleByName[name] = baseCountyStyle();

            const grp = countyGroup(name);
            const grpLabel = grp ? grp.toUpperCase() : "NONE";
            layer.bindTooltip(`${name} County`);
            layer.bindPopup(`<b>${name} County</b><br>Group: ${grpLabel}`);

            if (highlightState[name]) {
              setCountyHighlighted(name, true);
            }
          }
        }).addTo(map);

        // Apply team-based highlight rules immediately on load (default team is ALL)
        syncCountyHighlightsToTeamFilter();
      })
      .catch(err => console.error("GeoJSON load error:", err));

    // Init section map filter dropdown immediately
    sectionMapFilter.innerHTML = `<option value="ALL">All section maps</option>`;
  </script>

</body>
</html>
